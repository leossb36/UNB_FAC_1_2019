.data
    a: .byte 0
    bit7: .word 0
    bit6: .word 0
    bit5: .word 0
    bit4: .word 0
    bit3: .word 0
    bit2: .word 0
    bit1: .word 0
    bit0: .word 0

    print_bit_paridade: .asciiz "bit­paridade: "
    saida: .asciiz "\nsaida: "
    break_line: .asciiz "\n"
    error: .asciiz "\nentrada incorreta\n"
.text

main:
    
    li $v0, 5
    syscall # input de valor
    sw $v0, a # salva na memoria

    lw $s0, a # carrega registrador t1
    jal maior_que # checa se é maior que 128

    jal bit_paridade # faz calculo de paridade
    
    jal print_resultado

    li $v0, 10
    syscall #exit prog

maior_que:
    
    slti $t0, $s0, 128  #(arg < 128)
	beq $t1, $t0, exit_prog_error #se t3 for true retorna, se false error 

	jr $ra #retorna valor checado


bit_paridade:
    # primeiro de tudo devemos converter a entrada de hexa para binario
    # 127
    # 0x000007F
    # 0111 1111
    # maior representação possivel em hexa
    
    # 0000 0001 = 1
    # 0000 0010 = 2
    # 0000 0100 = 4
    # 0000 1000 = 8
    # 0001 0000 = 16
    # 0010 0000 = 32
    # 0100 0000 = 64

    # mascara 0100 0000 -> shiftando para direita e guardando os resultados
    # precisa de 7 registradores para comparar bit a bit
    # input = sum bits
    # compara com arg
    # guarda em novo registrador
    # definir mascara para shift

    add $t0, $t0, $zero # definindo ponto de parada
    addi $t1, $t1, 64 # definindo mascara
    addi $t3, $t3, 2 # operando para checar se é par ou impar
    
    and $t2, $s0, $t1 # A . mask = 0111 1111 . 0100 0000 = 0100 0000
    beq $t1, $t2, conta_bit # so é interessante contar os 1's
    add $v0, $t2, $zero # salva valor do bit
    sw $v0, bit7 # salva bit mais significativo na memoria
    srl $t1, $t1, 1 # shift mascara 1 bit para direita

    and $t2, $v0, $t1 # A . mask = 0111 1111 . 0010 0000 = 0010 0000
    beq $t1, $t2, conta_bit # so é interessante contar os 1's
    add $v0, $t2, $zero # guarda bit
    sw $v0, bit6 # salva sexto bit na memoria
    srl $t1, $t1, 1 # shift mascara 1 bit para direita            

    and $t2, $v0, $t1 # A . mask = 0111 1111 . 0001 0000 = 0001 0000
    beq $t1, $t2, conta_bit # so é interessante contar os 1's
    add $v0, $t2, $zero # guarda bit
    sw $v0, bit5 # salva quinto bit na memoria
    srl $t1, $t1, 1 # shift mascara 1 bit para direita
    
    and $t2, $v0, $t1 # A . mask = 0111 1111 . 0000 1000 = 0000 1000
    beq $t1, $t2, conta_bit # so é interessante contar os 1's
    add $v0, $t2, $zero # guarda bit
    sw $v0, bit4 #salva na memoria quarto bit
    srl $t1, $t1, 1 # shift mascara 1 bit para direita
    
    and $t2, $v0, $t1 # A . mask = 0111 1111 . 0000 0100 = 0000 0100
    beq $t1, $t2, conta_bit # so é interessante contar os 1's
    add $v0, $t2, $zero # guarda bit
    sw $v0, bit3 # salva terceiro bit
    srl $t1, $t1, 1 # shift mascara 1 bit para direita
    
    and $t2, $v0, $t1 # A . mask = 0111 1111 . 0000 0010 = 0000 0010
    beq $t1, $t2, conta_bit # so é interessante contar os 1's
    add $v0, $t2, $zero # guarda bit
    sw $v0, bit2 # salva na memoria segundo bit
    srl $t1, $t1, 1 # shift mascara 1 bit para direita
    
    and $t2, $v0, $t1 # A . mask = 0111 1111 . 0000 0001 = 0000 0001
    beq $t1, $t2, conta_bit # so é interessante contar os 1's
    add $v0, $t2, $zero # guarda bit
    sw $v0, bit1 # salva bit menos significativo na memoria
    srl $t1, $t1, 1 # shift mascara 1 bit para direita

    div $s3, $t3 # bits de 1's / 2
    mfhi $t4 # bits de 1's mod 2
    beq $t4, $zero, se_par # se ele for par vai add 1 bit significativo
    
    add $s4, $s4, $zero # se ele for impar vai dar resultado zero

    jr $ra

    se_par:
        addi $s4, $s4, 1
        addi $s0, $s0, 128
        move $v0, $s0
        sw $v0, bit0

        jr $ra

print_resultado:

    la $a0, print_bit_paridade
	
	li $v0, 4 #Chamada de sistema para print de string
	syscall
	
	li $v0, 1 #Chamada de sistema para print de valor
	move $a0, $s4
	syscall

	la $a0, saida
	
	li $v0, 4 #Chamada de sistema para print de string
	syscall
	
	li $v0, 1 #Chamada de sistema para print de valor
	move $a0, $s0
	syscall

    la $a0, break_line

    li $v0, 4
    syscall

    jr $ra

exit_prog_error:
	
    la $a0, error #printa erro

	li $v0, 4
	syscall

	li $v0, 10 # exit
	syscall
